<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=5">
    <title>YARV</title>
    <link rel="icon" href="favicon.svg">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Serif+Pro&amp;display=swap">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="highlight.css">
  </head>
  <body>
    <a href="https://github.com/kddnewton/yarv" style="position: absolute; right: 0; top: 0" aria-label="View source on GitHub">
      <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 250 250" fill="white">
        <path d="M0 0l115 115h15l12 27 108 108V0z" fill="var(--primary-color)" />
        <path d="M128 109c-15-9-9-19-9-19 3-7 2-11 2-11-1-7 3-2 3-2 4 5 2 11 2 11-3 10 5 15 9 16" style="transform-origin: 130px 106px" />
        <path d="M115 115s4 2 5 0l14-14c3-2 6-3 8-3-8-11-15-24 2-41 5-5 10-7 16-7 1-2 3-7 12-11 0 0 5 3 7 16 4 2 8 5 12 9s7 8 9 12c14 3 17 7 17 7-4 8-9 11-11 11 0 6-2 11-7 16-16 16-30 10-41 2 0 3-1 7-5 11l-12 11c-1 1 1 5 1 5z" />
      </svg>
    </a>
    <main>
      <aside>
  <header>
    <h1>YARV Instructions</h1>
  </header>
  <nav>
    <a href="#adjuststack">adjuststack</a>
<a href="#anytostring">anytostring</a>
<a href="#branchif">branchif</a>
<a href="#branchnil">branchnil</a>
<a href="#branchunless">branchunless</a>
<a href="#concatarray">concatarray</a>
<a href="#concatstrings">concatstrings</a>
<a href="#defined">defined</a>
<a href="#definemethod">definemethod</a>
<a href="#dup">dup</a>
<a href="#duphash">dup_hash</a>
<a href="#duparray">duparray</a>
<a href="#dupn">dupn</a>
<a href="#expandarray">expandarray</a>
<a href="#getconstant">getconstant</a>
<a href="#getglobal">getglobal</a>
<a href="#getlocal">getlocal</a>
<a href="#getlocalwc0">getlocal_wc_0</a>
<a href="#getlocalwc1">getlocal_wc_1</a>
<a href="#intern">intern</a>
<a href="#invokeblock">invokeblock</a>
<a href="#jump">jump</a>
<a href="#leave">leave</a>
<a href="#newarray">newarray</a>
<a href="#newhash">newhash</a>
<a href="#newrange">newrange</a>
<a href="#nop">nop</a>
<a href="#objtostring">objtostring</a>
<a href="#optand">opt_and</a>
<a href="#optaref">opt_aref</a>
<a href="#optarefwith">opt_aref_with</a>
<a href="#optaset">opt_aset</a>
<a href="#optasetwith">opt_aset_with</a>
<a href="#optcasedispatch">opt_case_dispatch</a>
<a href="#optdiv">opt_div</a>
<a href="#optemptyp">opt_empty_p</a>
<a href="#opteq">opt_eq</a>
<a href="#optge">opt_ge</a>
<a href="#optgetinlinecache">opt_getinlinecache</a>
<a href="#optgt">opt_gt</a>
<a href="#optle">opt_le</a>
<a href="#optlength">opt_length</a>
<a href="#optlt">opt_lt</a>
<a href="#optltlt">opt_ltlt</a>
<a href="#optminus">opt_minus</a>
<a href="#optmod">opt_mod</a>
<a href="#optmult">opt_mult</a>
<a href="#optneq">opt_neq</a>
<a href="#optnewarraymax">opt_newarray_max</a>
<a href="#optnewarraymin">opt_newarray_min</a>
<a href="#optnilp">opt_nil_p</a>
<a href="#optnot">opt_not</a>
<a href="#optor">opt_or</a>
<a href="#optplus">opt_plus</a>
<a href="#optregexpmatch2">opt_regexpmatch2</a>
<a href="#optsendwithoutblock">opt_send_without_block</a>
<a href="#optsetinlinecache">opt_setinlinecache</a>
<a href="#optsize">opt_size</a>
<a href="#optstrfreeze">opt_str_freeze</a>
<a href="#optstruminus">opt_str_uminus</a>
<a href="#optsucc">opt_succ</a>
<a href="#pop">pop</a>
<a href="#putnil">putnil</a>
<a href="#putobject">putobject</a>
<a href="#putobjectint2fix0">putobject_int2fix_0</a>
<a href="#putobjectint2fix1">putobject_int2fix_1</a>
<a href="#putself">putself</a>
<a href="#putstring">putstring</a>
<a href="#send">send</a>
<a href="#setglobal">setglobal</a>
<a href="#setlocal">setlocal</a>
<a href="#setlocalwc0">setlocal_wc_0</a>
<a href="#setlocalwc1">setlocal_wc_1</a>
<a href="#setn">setn</a>
<a href="#splatarray">splatarray</a>
<a href="#swap">swap</a>
<a href="#topn">topn</a>
<a href="#toregexp">toregexp</a>


  </nav>
</aside>
<article>
  <h2 id="adjuststack">adjuststack</h2>

<h3 id="summary">Summary</h3>

<p><code>adjuststack</code> accepts a single integer argument and removes that many
elements from the top of the stack.</p>

<h3 id="tracepoint">TracePoint</h3>

<p><code>adjuststack</code> cannot dispatch any TracePoint events.</p>

<h3 id="usage">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="kp">true</span><span class="p">]</span>
<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||=</span> <span class="kp">nil</span>
<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(3,4)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 duparray                               [true]                    (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          x@0</span>
<span class="c1"># 0004 getlocal_WC_0                          x@0                       (   2)[Li]</span>
<span class="c1"># 0006 putobject_INT2FIX_0_</span>
<span class="c1"># 0007 dupn                                   2</span>
<span class="c1"># 0009 opt_aref                               &lt;calldata!mid:[], argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0011 dup</span>
<span class="c1"># 0012 branchif                               21</span>
<span class="c1"># 0014 pop</span>
<span class="c1"># 0015 putnil</span>
<span class="c1"># 0016 opt_aset                               &lt;calldata!mid:[]=, argc:2, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0018 pop</span>
<span class="c1"># 0019 jump                                   23</span>
<span class="c1"># 0021 adjuststack                            3</span>
<span class="c1"># 0023 getlocal_WC_0                          x@0                       (   3)[Li]</span>
<span class="c1"># 0025 putobject_INT2FIX_0_</span>
<span class="c1"># 0026 opt_aref                               &lt;calldata!mid:[], argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0028 leave</span>
</code></pre></div></div>

<h2 id="anytostring">anytostring</h2>

<h3 id="summary-1">Summary</h3>

<p><code>anytostring</code> ensures that the value on top of the stack is a string.</p>

<p>It pops two values off the stack. If the first value is a string it pushes it back on
the stack. If the first value is not a string, it uses Ruby’s built in string coercion
to coerce the second value to a string and then pushes that back on the stack.</p>

<p>This is used in conjunction with <code>objtostring</code> as a fallback for when an object’s <code>to_s</code>
method does not return a string</p>

<h3 id="tracepoint-1">TracePoint</h3>

<p><code>anytostring</code> cannot dispatch any TracePoint events</p>

<h3 id="usage-1">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"</span><span class="si">#{</span><span class="mi">5</span><span class="si">}</span><span class="s2">"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 putobject                              5</span>
<span class="c1"># 0004 dup</span>
<span class="c1"># 0005 objtostring                            &lt;calldata!mid:to_s, argc:0, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0007 anytostring</span>
<span class="c1"># 0008 concatstrings                          2</span>
<span class="c1"># 0010 leave</span>
</code></pre></div></div>

<h2 id="branchif">branchif</h2>

<h3 id="summary-2">Summary</h3>

<p><code>branchif</code> has one argument: the jump index. It pops one value off the stack:
the jump condition.</p>

<p>If the value popped off the stack is true, <code>branchif</code> jumps to
the jump index and continues executing there.</p>

<h3 id="tracepoint-2">TracePoint</h3>

<p><code>branchif</code> does not dispatch any events.</p>

<h3 id="usage-2">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="kp">true</span>
<span class="n">x</span> <span class="o">||=</span> <span class="s2">"foo"</span>
<span class="nb">puts</span> <span class="n">x</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(3,6)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 putobject                              true                      (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          x@0</span>
<span class="c1"># 0004 getlocal_WC_0                          x@0                       (   2)[Li]</span>
<span class="c1"># 0006 dup</span>
<span class="c1"># 0007 branchif                               15</span>
<span class="c1"># 0009 pop</span>
<span class="c1"># 0010 putstring                              "foo"</span>
<span class="c1"># 0012 dup</span>
<span class="c1"># 0013 setlocal_WC_0                          x@0</span>
<span class="c1"># 0015 pop</span>
<span class="c1"># 0016 putself                                                          (   3)[Li]</span>
<span class="c1"># 0017 getlocal_WC_0                          x@0</span>
<span class="c1"># 0019 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0021 leave</span>
</code></pre></div></div>

<h2 id="branchnil">branchnil</h2>

<h3 id="summary-3">Summary</h3>

<p><code>branchnil</code> has one argument: the jump index. It pops one value off the stack:
the jump condition.</p>

<p>If the value popped off the stack is nil, <code>branchnil</code> jumps to
the jump index and continues executing there.</p>

<h3 id="tracepoint-3">TracePoint</h3>

<p>There is no trace point for <code>branchnil</code>.</p>

<h3 id="usage-3">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">if</span> <span class="n">x</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="nb">puts</span> <span class="s2">"hi"</span>
<span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(4,3)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 putnil                                                           (   1)[Li]</span>
<span class="c1"># 0001 setlocal_WC_0                          x@0</span>
<span class="c1"># 0003 getlocal_WC_0                          x@0                       (   2)[Li]</span>
<span class="c1"># 0005 dup</span>
<span class="c1"># 0006 branchnil                              10</span>
<span class="c1"># 0008 opt_send_without_block                 &lt;calldata!mid:to_s, argc:0, ARGS_SIMPLE&gt;</span>
<span class="c1"># 0010 branchunless                           18</span>
<span class="c1"># 0012 putself                                                          (   3)[Li]</span>
<span class="c1"># 0013 putstring                              "hi"</span>
<span class="c1"># 0015 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0017 leave</span>
<span class="c1"># 0018 putnil</span>
<span class="c1"># 0019 leave</span>
</code></pre></div></div>

<h2 id="branchunless">branchunless</h2>

<h3 id="summary-4">Summary</h3>

<p><code>branchunless</code> has one argument, the jump index
and pops one value off the stack, the jump condition.</p>

<p>If the value popped off the stack is false or nil,
<code>branchunless</code> jumps to the jump index and continues executing there.</p>

<h3 id="tracepoint-4">TracePoint</h3>

<p><code>branchunless</code> does not dispatch any events.</p>

<h3 id="usage-4">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
  <span class="nb">puts</span> <span class="s2">"foo"</span>
<span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_plus                               &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 branchunless                           14</span>
<span class="c1"># 0008 putself                                                          (   2)[Li]</span>
<span class="c1"># 0009 putstring                              "foo"</span>
<span class="c1"># 0011 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0013 leave</span>
<span class="c1"># 0014 putnil</span>
<span class="c1"># 0015 leave</span>
</code></pre></div></div>

<h2 id="concatarray">concatarray</h2>

<h3 id="summary-5">Summary</h3>

<p><code>concatarray</code> concatenates the two Arrays on top of the stack.</p>

<p>It coerces the two objects at the top of the stack into Arrays by calling
<code>to_a</code> if necessary, and makes sure to <code>dup</code> the first Array if it was
already an Array, to avoid mutating it when concatenating.</p>

<h3 id="tracepoint-5">TracePoint</h3>

<p><code>concatarray</code> can dispatch the <code>line</code> and <code>call</code> events.</p>

<h3 id="usage-5">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 duparray                               [1]                       (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 concatarray</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="concatstrings">concatstrings</h2>

<h3 id="summary-6">Summary</h3>

<p><code>concatstrings</code> just pops a number of strings from the stack joins them together
into a single string and pushes that string back on the stack.</p>

<p>This does no coercion and so is always used in conjunction with <code>objtostring</code>
and <code>anytostring</code> to ensure the stack contents are always strings</p>

<h3 id="tracepoint-6">TracePoint</h3>

<p><code>concatstrings</code> can dispatch the <code>line</code> and <code>call</code> events.</p>

<h3 id="usage-6">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"</span><span class="si">#{</span><span class="mi">5</span><span class="si">}</span><span class="s2">"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 putobject                              5</span>
<span class="c1"># 0004 dup</span>
<span class="c1"># 0005 objtostring                            &lt;calldata!mid:to_s, argc:0, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0007 anytostring</span>
<span class="c1"># 0008 concatstrings                          2</span>
<span class="c1"># 0010 leave</span>
</code></pre></div></div>

<h2 id="defined">defined</h2>

<h3 id="summary-7">Summary</h3>

<p><code>defined</code> checks if the top value of the stack is defined. If it is, it
pushes its value onto the stack. Otherwise it pushes <code>nil</code>.</p>

<h3 id="tracepoint-7">TracePoint</h3>

<p><code>defined</code> cannot dispatch any TracePoint events.</p>

<h3 id="usage-7">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defined?</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,11)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putself                                                          (   1)[Li]</span>
<span class="c1"># 0001 defined                                func, :x, "method"</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="definemethod">definemethod</h2>

<h3 id="summary-8">Summary</h3>

<p><code>definemethod</code> defines a method on the class of the current value of <code>self</code>.
It accepts two arguments. The first is the name of the method being defined.
The second is the instruction sequence representing the body of the method.</p>

<h3 id="tracepoint-8">TracePoint</h3>

<p><code>definemethod</code> does not dispatch any events.</p>

<h3 id="usage-8">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">value</span> <span class="o">=</span> <span class="s2">"value"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,19)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 definemethod                           :value, value             (   1)[Li]</span>
<span class="c1"># 0003 putobject                              :value</span>
<span class="c1"># 0005 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:value@&lt;compiled&gt;:1 (1,0)-(1,19)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              "value"                   (   1)[Ca]</span>
<span class="c1"># 0002 leave                                  [Re]</span>
</code></pre></div></div>

<h2 id="dup">dup</h2>

<h3 id="summary-9">Summary</h3>

<p><code>dup</code> copies the top value of the stack and pushes it onto the stack.</p>

<h3 id="tracepoint-9">TracePoint</h3>

<p><code>dup</code> does not dispatch any events.</p>

<h3 id="usage-9">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$global</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,11)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 setglobal                              :$global</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="duphash">dup_hash</h2>

<h3 id="summary-10">Summary</h3>

<p><code>duphash</code> pushes a hash onto the stack</p>

<h3 id="tracepoint-10">TracePoint</h3>

<p><code>duphash</code> can dispatch the line event.</p>

<h3 id="usage-10">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="ss">a: </span><span class="mi">1</span> <span class="p">}</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 duphash                                {:a=&gt;1}                   (   1)[Li]</span>
<span class="c1"># 0002 leave</span>
</code></pre></div></div>

<h2 id="duparray">duparray</h2>

<h3 id="summary-11">Summary</h3>

<p><code>duparray</code> copies a literal Array and pushes it onto the stack.</p>

<h3 id="tracepoint-11">TracePoint</h3>

<p><code>duparray</code> can dispatch the <code>line</code> event.</p>

<h3 id="usage-11">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="kp">true</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 duparray                               [true]                    (   1)[Li]</span>
<span class="c1"># 0002 leave</span>
</code></pre></div></div>

<h2 id="dupn">dupn</h2>

<h3 id="summary-12">Summary</h3>

<p><code>dupn</code> duplicates the top <code>n</code> stack elements.</p>

<h3 id="tracepoint-12">TracePoint</h3>

<p><code>dupn</code> does not dispatch any TracePoint events.</p>

<h3 id="usage-12">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Object</span><span class="o">::</span><span class="no">X</span> <span class="o">||=</span> <span class="kp">true</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,18)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]</span>
<span class="c1"># 0003 putobject                              true</span>
<span class="c1"># 0005 getconstant                            :Object</span>
<span class="c1"># 0007 opt_setinlinecache                     &lt;is:0&gt;</span>
<span class="c1"># 0009 dup</span>
<span class="c1"># 0010 defined                                constant-from, :X, true</span>
<span class="c1"># 0014 branchunless                           25</span>
<span class="c1"># 0016 dup</span>
<span class="c1"># 0017 putobject                              true</span>
<span class="c1"># 0019 getconstant                            :X</span>
<span class="c1"># 0021 dup</span>
<span class="c1"># 0022 branchif                               32</span>
<span class="c1"># 0024 pop</span>
<span class="c1"># 0025 putobject                              true</span>
<span class="c1"># 0027 dupn                                   2</span>
<span class="c1"># 0029 swap</span>
<span class="c1"># 0030 setconstant                            :X</span>
<span class="c1"># 0032 swap</span>
<span class="c1"># 0033 pop</span>
<span class="c1"># 0034 leave</span>
</code></pre></div></div>

<h2 id="expandarray">expandarray</h2>

<h3 id="summary-13">Summary</h3>

<p><code>expandarray</code> looks at the top of the stack, and if the value is an array
it replaces it on the stack with <code>num</code> elements of the array, or <code>nil</code> if
the elements are missing.</p>

<h3 id="tracepoint-13">TracePoint</h3>

<p><code>expandarray</code> does not dispatch any events.</p>

<h3 id="usage-13">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">,</span> <span class="o">=</span> <span class="p">[</span><span class="kp">true</span><span class="p">,</span> <span class="kp">false</span><span class="p">,</span> <span class="kp">nil</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,23)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 duparray                               [true, false, nil]        (   1)[Li]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 expandarray                            1, 0</span>
<span class="c1"># 0006 setlocal_WC_0                          x@0</span>
<span class="c1"># 0008 leave</span>
</code></pre></div></div>

<h2 id="getconstant">getconstant</h2>

<h3 id="summary-14">Summary</h3>

<p><code>getconstant</code> performs a constant lookup and pushes the value of the
constant onto the stack.</p>

<h3 id="tracepoint-14">TracePoint</h3>

<p><code>getconstant</code> does not dispatch any events.</p>

<h3 id="usage-14">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Constant</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]</span>
<span class="c1"># 0003 putobject                              true</span>
<span class="c1"># 0005 getconstant                            :Constant</span>
<span class="c1"># 0007 opt_setinlinecache                     &lt;is:0&gt;</span>
<span class="c1"># 0009 leave</span>
</code></pre></div></div>

<h2 id="getglobal">getglobal</h2>

<h3 id="summary-15">Summary</h3>

<p><code>getglobal</code> pushes the value of a global variables onto the stack.</p>

<h3 id="tracepoint-15">TracePoint</h3>

<p><code>getglobal</code> does not dispatch any events.</p>

<h3 id="usage-15">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$$</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,2)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 getglobal                              :$$                       (   1)[Li]</span>
<span class="c1"># 0002 leave</span>
</code></pre></div></div>

<h2 id="getlocal">getlocal</h2>

<h3 id="summary-16">Summary</h3>

<p><code>getlocal</code> fetches the value of a local variable from a frame determined by
the level and index arguments. The level is the number of frames back to
look and the index is the index in the local table. It pushes the value it
finds onto the stack.</p>

<h3 id="tracepoint-16">TracePoint</h3>

<p><code>getlocal</code> does not dispatch any events.</p>

<h3 id="usage-16">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tap</span> <span class="p">{</span> <span class="n">tap</span> <span class="p">{</span> <span class="n">value</span> <span class="p">}</span> <span class="p">}</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(2,21)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] value@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          value@0</span>
<span class="c1"># 0004 putself                                                          (   2)[Li]</span>
<span class="c1"># 0005 send                                   &lt;calldata!mid:tap, argc:0, FCALL&gt;, block in &lt;compiled&gt;</span>
<span class="c1"># 0008 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block in &lt;compiled&gt;@&lt;compiled&gt;:2 (2,4)-(2,21)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putself                                                          (   2)[LiBc]</span>
<span class="c1"># 0001 send                                   &lt;calldata!mid:tap, argc:0, FCALL&gt;, block (2 levels) in &lt;compiled&gt;</span>
<span class="c1"># 0004 leave                                  [Br]</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block (2 levels) in &lt;compiled&gt;@&lt;compiled&gt;:2 (2,10)-(2,19)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 getlocal                               value@0, 2                (   2)[LiBc]</span>
<span class="c1"># 0003 leave                                  [Br]</span>
</code></pre></div></div>

<h2 id="getlocalwc0">getlocal_wc_0</h2>

<h3 id="summary-17">Summary</h3>

<p><code>getlocal_WC_0</code> is a specialized version of the <code>getlocal</code> instruction. It
fetches the value of a local variable from the current frame determined by
the index given as its only argument.</p>

<h3 id="tracepoint-17">TracePoint</h3>

<p><code>getlocal_WC_0</code> does not dispatch any events.</p>

<h3 id="usage-17">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">value</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(2,5)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] value@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          value@0</span>
<span class="c1"># 0004 getlocal_WC_0                          value@0                   (   2)[Li]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="getlocalwc1">getlocal_wc_1</h2>

<h3 id="summary-18">Summary</h3>

<p><code>getlocal_WC_1</code> is a specialized version of the <code>getlocal</code> instruction. It
fetches the value of a local variable from the parent frame determined by
the index given as its only argument.</p>

<h3 id="tracepoint-18">TracePoint</h3>

<p><code>getlocal_WC_1</code> does not dispatch any events.</p>

<h3 id="usage-18">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">self</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">value</span> <span class="p">}</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(2,19)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] value@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          value@0</span>
<span class="c1"># 0004 putself                                                          (   2)[Li]</span>
<span class="c1"># 0005 send                                   &lt;calldata!mid:then, argc:0, FCALL&gt;, block in &lt;compiled&gt;</span>
<span class="c1"># 0008 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block in &lt;compiled&gt;@&lt;compiled&gt;:2 (2,10)-(2,19)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 getlocal_WC_1                          value@0                   (   2)[LiBc]</span>
<span class="c1"># 0002 leave                                  [Br]</span>
</code></pre></div></div>

<h2 id="intern">intern</h2>

<h3 id="summary-19">Summary</h3>

<p><code>intern</code> converts top element from stack to a symbol.</p>

<h3 id="tracepoint-19">TracePoint</h3>

<p>There is no trace point for <code>intern</code>.</p>

<h3 id="usage-19">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="ss">:"</span><span class="si">#{</span><span class="s2">"foo"</span><span class="si">}</span><span class="ss">"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,11)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              "foo"                     (   1)[Li]</span>
<span class="c1"># 0002 intern</span>
<span class="c1"># 0003 leave</span>
</code></pre></div></div>

<h2 id="invokeblock">invokeblock</h2>

<h3 id="summary-20">Summary</h3>

<p><code>invokeblock</code> invokes the block passed to a method during a yield.</p>

<h3 id="tracepoint-20">TracePoint</h3>

<h3 id="usage-20">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="k">yield</span><span class="p">;</span> <span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,19)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 definemethod                           :foo, foo                 (   1)[Li]</span>
<span class="c1"># 0003 putobject                              :foo</span>
<span class="c1"># 0005 leave</span>
<span class="c1">#</span>
<span class="c1"># == disasm: #&lt;ISeq:foo@-e:1 (1,0)-(1,19)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 invokeblock                            &lt;calldata!argc:0, ARGS_SIMPLE&gt;(   1)[LiCa]</span>
<span class="c1"># 0002 leave                                  [Re]</span>
<span class="c1"># ~~~</span>

<span class="c1">## jump</span>

<span class="c1">### Summary</span>

<span class="sb">`jump`</span> <span class="n">has</span> <span class="n">one</span> <span class="n">argument</span><span class="p">,</span> <span class="n">the</span> <span class="n">jump</span> <span class="n">index</span><span class="p">,</span> <span class="n">which</span> <span class="n">it</span> <span class="n">uses</span> <span class="n">to</span> <span class="n">set</span> <span class="n">the</span> <span class="k">next</span>
<span class="n">instruction</span> <span class="n">to</span> <span class="n">execute</span><span class="o">.</span>

<span class="c1">### TracePoint</span>

<span class="no">There</span> <span class="n">is</span> <span class="n">no</span> <span class="n">trace</span> <span class="n">point</span> <span class="k">for</span> <span class="sb">`jump`</span><span class="o">.</span>

<span class="c1">### Usage</span>

<span class="o">~~~</span><span class="n">ruby</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="nb">puts</span> <span class="s2">"0"</span>
<span class="k">else</span>
  <span class="nb">puts</span> <span class="s2">"2"</span>
<span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(6,3)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] y@0</span>
<span class="c1"># 0000 putobject_INT2FIX_0_                                             (   1)[Li]</span>
<span class="c1"># 0001 setlocal_WC_0                          y@0</span>
<span class="c1"># 0003 getlocal_WC_0                          y@0                       (   2)[Li]</span>
<span class="c1"># 0005 putobject_INT2FIX_0_</span>
<span class="c1"># 0006 opt_eq                                 &lt;calldata!mid:==, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0008 branchunless                           16</span>
<span class="c1"># 0010 putself                                                          (   3)[Li]</span>
<span class="c1"># 0011 putstring                              "0"</span>
<span class="c1"># 0013 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0015 leave                                                            (   5)</span>
<span class="c1"># 0016 putself                                [Li]</span>
<span class="c1"># 0017 putstring                              "2"</span>
<span class="c1"># 0019 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0021 leave</span>
</code></pre></div></div>

<h2 id="leave">leave</h2>

<h3 id="summary-21">Summary</h3>

<p><code>leave</code> exits the current frame.</p>

<h3 id="tracepoint-21">TracePoint</h3>

<p><code>leave</code> does not dispatch any events.</p>

<h3 id="usage-21">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">;;</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,2)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putnil                                                           (   1)</span>
<span class="c1"># 0001 leave</span>
</code></pre></div></div>

<h2 id="newarray">newarray</h2>

<h3 id="summary-22">Summary</h3>

<p><code>newarray</code> puts a new array initialized with <code>size</code> values from the stack.</p>

<h3 id="tracepoint-22">TracePoint</h3>

<p><code>newarray</code> dispatches a <code>line</code> event.</p>

<h3 id="usage-22">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="s2">"string"</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              "string"                  (   1)[Li]</span>
<span class="c1"># 0002 newarray                               1</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="newhash">newhash</h2>

<h3 id="summary-23">Summary</h3>

<p><code>newhash</code> puts a new hash onto the stack, using <code>num</code> elements from the
stack. <code>num</code> needs to be even.</p>

<h3 id="tracepoint-23">TracePoint</h3>

<p><code>newhash</code> does not dispatch any events.</p>

<h3 id="usage-23">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">{</span> <span class="n">key</span> <span class="o">=&gt;</span> <span class="n">value</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 definemethod                           :foo, foo                 (   1)[Li]</span>
<span class="c1"># 0003 putobject                              :foo</span>
<span class="c1"># 0005 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:foo@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 2, argc: 2 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 2] key@0&lt;Arg&gt; [ 1] value@1&lt;Arg&gt;</span>
<span class="c1"># 0000 getlocal_WC_0                          key@0                     (   2)[LiCa]</span>
<span class="c1"># 0002 getlocal_WC_0                          value@1</span>
<span class="c1"># 0004 newhash                                2</span>
<span class="c1"># 0006 leave                                                            (   3)[Re]</span>
</code></pre></div></div>

<h2 id="newrange">newrange</h2>

<h3 id="summary-24">Summary</h3>

<p><code>newrange</code> creates a Range. It takes one arguments, which is 0 if the end
is included or 1 if the end value is excluded.</p>

<h3 id="tracepoint-24">TracePoint</h3>

<p><code>newrange</code> does not dispatch any events.</p>

<h3 id="usage-24">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">p</span> <span class="p">(</span><span class="n">x</span><span class="o">..</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="o">...</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(3,17)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 2] x@0        [ 1] y@1</span>
<span class="c1"># 0000 putobject_INT2FIX_0_                                             (   1)[Li]</span>
<span class="c1"># 0001 setlocal_WC_0                          x@0</span>
<span class="c1"># 0003 putobject_INT2FIX_1_                                             (   2)[Li]</span>
<span class="c1"># 0004 setlocal_WC_0                          y@1</span>
<span class="c1"># 0006 putself                                                          (   3)[Li]</span>
<span class="c1"># 0007 getlocal_WC_0                          x@0</span>
<span class="c1"># 0009 getlocal_WC_0                          y@1</span>
<span class="c1"># 0011 newrange                               0</span>
<span class="c1"># 0013 getlocal_WC_0                          x@0</span>
<span class="c1"># 0015 getlocal_WC_0                          y@1</span>
<span class="c1"># 0017 newrange                               1</span>
<span class="c1"># 0019 opt_send_without_block                 &lt;calldata!mid:p, argc:2, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0021 leave</span>
</code></pre></div></div>

<h2 id="nop">nop</h2>

<h3 id="summary-25">Summary</h3>

<p><code>nop</code> is a no-operation instruction. It is used to pad the instruction
sequence so there is a place for other instructions to jump to.</p>

<h3 id="tracepoint-25">TracePoint</h3>

<p><code>nop</code> does not dispatch any events.</p>

<h3 id="usage-25">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">raise</span> <span class="k">rescue</span> <span class="kp">true</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,17)&gt; (catch: TRUE)</span>
<span class="c1"># == catch table</span>
<span class="c1"># | catch type: rescue st: 0000 ed: 0003 sp: 0000 cont: 0004</span>
<span class="c1"># | == disasm: #&lt;ISeq:rescue in &lt;compiled&gt;@&lt;compiled&gt;:1 (1,6)-(1,17)&gt; (catch: TRUE)</span>
<span class="c1"># | local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># | [ 1] $!@0</span>
<span class="c1"># | 0000 getlocal_WC_0                          $!@0                      (   1)</span>
<span class="c1"># | 0002 putobject                              StandardError</span>
<span class="c1"># | 0004 checkmatch                             3</span>
<span class="c1"># | 0006 branchunless                           11</span>
<span class="c1"># | 0008 putobject                              true</span>
<span class="c1"># | 0010 leave</span>
<span class="c1"># | 0011 getlocal_WC_0                          $!@0</span>
<span class="c1"># | 0013 throw                                  0</span>
<span class="c1"># | catch type: retry  st: 0003 ed: 0004 sp: 0000 cont: 0000</span>
<span class="c1"># |------------------------------------------------------------------------</span>
<span class="c1"># 0000 putself                                                          (   1)[Li]</span>
<span class="c1"># 0001 opt_send_without_block                 &lt;calldata!mid:raise, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0003 nop</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="objtostring">objtostring</h2>

<h3 id="summary-26">Summary</h3>

<p><code>objtostring</code> pops a value from the stack, calls <code>to_s</code> on that value and then pushes
the result back to the stack.</p>

<p>It has fast paths for String, Symbol, Module, Class, Nil, True, False &amp; Number.
For everything else it calls <code>to_s</code></p>

<h3 id="tracepoint-26">TracePoint</h3>

<p><code>objtostring</code> cannot dispatch any TracePoint events.</p>

<h3 id="usage-26">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"</span><span class="si">#{</span><span class="mi">5</span><span class="si">}</span><span class="s2">"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 putobject                              5</span>
<span class="c1"># 0004 dup</span>
<span class="c1"># 0005 objtostring                            &lt;calldata!mid:to_s, argc:0, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0007 anytostring</span>
<span class="c1"># 0008 concatstrings                          2</span>
<span class="c1"># 0010 leave</span>
</code></pre></div></div>

<h2 id="optand">opt_and</h2>

<h3 id="summary-27">Summary</h3>

<p><code>opt_and</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>&amp;</code> operator is used. In CRuby, there are fast paths
for if both operands are integers.</p>

<h3 id="tracepoint-27">TracePoint</h3>

<p><code>opt_and</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-27">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">&amp;</span> <span class="mi">3</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_and                                &lt;calldata!mid:&amp;, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optaref">opt_aref</h2>

<h3 id="summary-28">Summary</h3>

<p><code>opt_aref</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>[]</code> operator is used. In CRuby, there are fast paths
if the receiver is an integer, array, or hash.</p>

<h3 id="tracepoint-28">TracePoint</h3>

<p><code>opt_aref</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-28">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">7</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,4)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              7                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_aref                               &lt;calldata!mid:[], argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optarefwith">opt_aref_with</h2>

<h3 id="summary-29">Summary</h3>

<p><code>opt_aref_with</code> is a specialization of the <code>opt_aref</code> instruction that
occurs when the <code>[]</code> operator is used with a string argument known at
compile time. In CRuby, there are fast paths if the receiver is a hash.</p>

<h3 id="tracepoint-29">TracePoint</h3>

<p><code>opt_aref_with</code> does not dispatch any events.</p>

<h3 id="usage-29">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="s1">'test'</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="p">}[</span><span class="s1">'test'</span><span class="p">]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,26)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 duphash                                {"test"=&gt;true}            (   1)[Li]</span>
<span class="c1"># 0002 opt_aref_with                          "test", &lt;calldata!mid:[], argc:1, ARGS_SIMPLE&gt;</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="optaset">opt_aset</h2>

<h3 id="summary-30">Summary</h3>

<p><code>opt_aset</code> is an instruction for setting the hash value by the key in <code>recv[obj] = set</code> format</p>

<h3 id="tracepoint-30">TracePoint</h3>

<p>There is no trace point for <code>opt_aset</code>.</p>

<h3 id="usage-30">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{}[</span><span class="ss">:key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,16)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putnil                                                           (   1)[Li]</span>
<span class="c1"># 0001 newhash                                0</span>
<span class="c1"># 0003 putobject                              :key</span>
<span class="c1"># 0005 putself</span>
<span class="c1"># 0006 opt_send_without_block                 &lt;calldata!mid:value, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0008 setn                                   3</span>
<span class="c1"># 0010 opt_aset                               &lt;calldata!mid:[]=, argc:2, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0012 pop</span>
<span class="c1"># 0013 leave</span>
</code></pre></div></div>

<h2 id="optasetwith">opt_aset_with</h2>

<h3 id="summary-31">Summary</h3>

<p><code>opt_aset_with</code> is an instruction for setting the hash value by the known
string key in the <code>recv[obj] = set</code> format.</p>

<h3 id="tracepoint-31">TracePoint</h3>

<p>There is no trace point for <code>opt_aset_with</code>.</p>

<h3 id="usage-31">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{}[</span><span class="s2">"key"</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,17)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 newhash                                0                         (   1)[Li]</span>
<span class="c1"># 0002 putself</span>
<span class="c1"># 0003 opt_send_without_block                 &lt;calldata!mid:value, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0005 swap</span>
<span class="c1"># 0006 topn                                   1</span>
<span class="c1"># 0008 opt_aset_with                          "key", &lt;calldata!mid:[]=, argc:2, ARGS_SIMPLE&gt;</span>
<span class="c1"># 0011 pop</span>
<span class="c1"># 0012 leave</span>
</code></pre></div></div>

<h2 id="optcasedispatch">opt_case_dispatch</h2>

<h3 id="summary-32">Summary</h3>

<p><code>opt_case_dispatch</code> is a branch instruction that moves the control flow for
case statements.</p>

<p>It has two arguments: the cdhash and an else_offset index. It pops one value off
the stack: a hash key. <code>opt_case_dispatch</code> looks up the key in the cdhash
and jumps to the corresponding index value, if there is one.
If there is no value in the cdhash, <code>opt_case_dispatch</code> jumps to the else_offset index.</p>

<p>The cdhash is a Ruby hash used for handling optimized <code>case</code> statements.
The keys are the conditions of <code>when</code> clauses in the <code>case</code> statement,
and the values are the labels to which to jump. This optimization can be
applied only when the keys can be directly compared.</p>

<h3 id="tracepoint-32">TracePoint</h3>

<p>There is no trace point for <code>opt_case_dispatch</code>.</p>

<h3 id="usage-32">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">1</span>
<span class="k">when</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="s2">"foo"</span>
<span class="k">else</span>
  <span class="nb">puts</span> <span class="s2">"bar"</span>
<span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,49)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject_INT2FIX_0_                                             (   1)[Li]</span>
<span class="c1"># 0001 dup</span>
<span class="c1"># 0002 opt_case_dispatch                      &lt;cdhash&gt;, 12</span>
<span class="c1"># 0005 putobject_INT2FIX_1_</span>
<span class="c1"># 0006 topn                                   1</span>
<span class="c1"># 0008 opt_send_without_block                 &lt;calldata!mid:===, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0010 branchif                               19</span>
<span class="c1"># 0012 pop</span>
<span class="c1"># 0013 putself</span>
<span class="c1"># 0014 putstring                              "bar"</span>
<span class="c1"># 0016 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0018 leave</span>
<span class="c1"># 0019 pop</span>
<span class="c1"># 0020 putself</span>
<span class="c1"># 0021 putstring                              "foo"</span>
<span class="c1"># 0023 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0025 leave</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(6,3)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject_INT2FIX_1_                                             (   1)[Li]</span>
<span class="c1"># 0001 dup</span>
<span class="c1"># 0002 opt_case_dispatch                      &lt;cdhash&gt;, 12</span>
<span class="c1"># 0005 putobject_INT2FIX_1_                                             (   2)</span>
<span class="c1"># 0006 topn                                   1</span>
<span class="c1"># 0008 opt_send_without_block                 &lt;calldata!mid:===, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0010 branchif                               19</span>
<span class="c1"># 0012 pop                                                              (   5)</span>
<span class="c1"># 0013 putself                                [Li]</span>
<span class="c1"># 0014 putstring                              "bar"</span>
<span class="c1"># 0016 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0018 leave</span>
<span class="c1"># 0019 pop                                                              (   2)</span>
<span class="c1"># 0020 putself                                                          (   3)[Li]</span>
<span class="c1"># 0021 putstring                              "foo"</span>
<span class="c1"># 0023 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0025 leave                                                            (   5)</span>
</code></pre></div></div>

<h2 id="optdiv">opt_div</h2>

<h3 id="summary-33">Summary</h3>

<p><code>opt_div</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>/</code> operator is used. In CRuby, there are fast paths
for if both operands are integers, or if both operands are floats.</p>

<h3 id="tracepoint-33">TracePoint</h3>

<p><code>opt_div</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-33">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_div                                &lt;calldata!mid:/, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optemptyp">opt_empty_p</h2>

<h3 id="summary-34">Summary</h3>

<p><code>opt_empty_p</code> is an optimization applied when the method <code>empty?</code> is called
on a String, Array or a Hash. This optimization can be applied because Ruby
knows how to calculate the length of these objects using internal C macros.</p>

<h3 id="tracepoint-34">TracePoint</h3>

<p><code>opt_empty_p</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-34">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">""</span><span class="p">.</span><span class="nf">empty?</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 opt_empty_p                            &lt;calldata!mid:empty?, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="opteq">opt_eq</h2>

<h3 id="summary-35">Summary</h3>

<p><code>opt_eq</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the == operator is used. Fast paths exist within CRuby when
both operands are integers, floats, symbols or strings.</p>

<h3 id="tracepoint-35">TracePoint</h3>

<p><code>opt_eq</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-35">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_eq                                 &lt;calldata!mid:==, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optge">opt_ge</h2>

<h3 id="summary-36">Summary</h3>

<p><code>opt_ge</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the &gt;= operator is used. Fast paths exist within CRuby when
both operands are integers or floats.</p>

<h3 id="tracepoint-36">TracePoint</h3>

<p><code>opt_ge</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-36">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;=</span> <span class="mi">3</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              4                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_ge                                 &lt;calldata!mid:&gt;=, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optgetinlinecache">opt_getinlinecache</h2>

<h3 id="summary-37">Summary</h3>

<p><code>opt_getinlinecache</code> is a wrapper around a series of <code>getconstant</code>
instructions that allows skipping past them if the inline cache is currently
set.</p>

<h3 id="tracepoint-37">TracePoint</h3>

<p><code>opt_getinlinecache</code> does not dispatch any events.</p>

<h3 id="usage-37">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Constant</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]</span>
<span class="c1"># 0003 putobject                              true</span>
<span class="c1"># 0005 getconstant                            :Constant</span>
<span class="c1"># 0007 opt_setinlinecache                     &lt;is:0&gt;</span>
<span class="c1"># 0009 leave</span>
</code></pre></div></div>

<h2 id="optgt">opt_gt</h2>

<h3 id="summary-38">Summary</h3>

<p><code>opt_gt</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the &gt; operator is used. Fast paths exist within CRuby when
both operands are integers or floats.</p>

<h3 id="tracepoint-38">TracePoint</h3>

<p><code>opt_gt</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-38">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">&gt;</span> <span class="mi">3</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              4                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_gt                                 &lt;calldata!mid:&gt;, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optle">opt_le</h2>

<h3 id="summary-39">Summary</h3>

<p><code>opt_le</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the &lt;= operator is used. Fast paths exist within CRuby when
both operands are integers or floats.</p>

<h3 id="tracepoint-39">TracePoint</h3>

<p><code>opt_le</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-39">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">&lt;=</span> <span class="mi">4</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              3                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              4</span>
<span class="c1"># 0004 opt_le                                 &lt;calldata!mid:&lt;=, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optlength">opt_length</h2>

<h3 id="summary-40">Summary</h3>

<p><code>opt_length</code> is a specialization of <code>opt_send_without_block</code>, when the
<code>length</code> method is called on a Ruby type with a known size. In CRuby there
are fast paths when the receiver is either a String, Hash or Array.</p>

<h3 id="tracepoint-40">TracePoint</h3>

<p><code>opt_length</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-40">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">""</span><span class="p">.</span><span class="nf">length</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 opt_length                             &lt;calldata!mid:length, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="optlt">opt_lt</h2>

<h3 id="summary-41">Summary</h3>

<p><code>opt_lt</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the &lt; operator is used. Fast paths exist within CRuby when
both operands are integers or floats.</p>

<h3 id="tracepoint-41">TracePoint</h3>

<p><code>opt_lt</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-41">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">4</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              3                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              4</span>
<span class="c1"># 0004 opt_lt                                 &lt;calldata!mid:&lt;, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optltlt">opt_ltlt</h2>

<h3 id="summary-42">Summary</h3>

<p><code>opt_ltlt</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>&lt;&lt;</code> operator is used. Fast paths exists when the
receiver is either a String or an Array</p>

<h3 id="tracepoint-42">TracePoint</h3>

<p><code>opt_ltlt</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-42">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">""</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_ltlt                               &lt;calldata!mid:&lt;&lt;, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_ltlt                               &lt;calldata!mid:&lt;&lt;, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optminus">opt_minus</h2>

<h3 id="summary-43">Summary</h3>

<p><code>opt_minus</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>-</code> operator is used. In CRuby, there are fast paths
for if both operands are integers or both operands are floats.</p>

<h3 id="tracepoint-43">TracePoint</h3>

<p><code>opt_minus</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-43">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              3                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_minus                              &lt;calldata!mid:-, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optmod">opt_mod</h2>

<h3 id="summary-44">Summary</h3>

<p><code>opt_mod</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>%</code> operator is used. In CRuby, there are fast paths
for if both operands are integers or both operands are floats.</p>

<h3 id="tracepoint-44">TracePoint</h3>

<p><code>opt_eq</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-44">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">%</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              4                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_mod                                &lt;calldata!mid:%, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optmult">opt_mult</h2>

<h3 id="summary-45">Summary</h3>

<p><code>opt_mult</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>*</code> operator is used. In CRuby, there are fast paths
for if both operands are integers or floats.</p>

<h3 id="tracepoint-45">TracePoint</h3>

<p><code>opt_mult</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-45">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              3                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_mult                               &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optneq">opt_neq</h2>

<h3 id="summary-46">Summary</h3>

<p><code>opt_neq</code> is an optimisation that tests whether two values at the top of
the stack are not equal by testing their equality and performing a logical
NOT on the result.</p>

<p>This allows <code>opt_neq</code> to use the fast paths optimized in <code>opt_eq</code> when both
operands are Integers, Floats, Symbols or Strings.</p>

<h3 id="tracepoint-46">TracePoint</h3>

<p><code>opt_neq</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-46">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">!=</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,6)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              2</span>
<span class="c1"># 0004 opt_neq                                &lt;calldata!mid:==, argc:1, ARGS_SIMPLE&gt;, &lt;calldata!mid:!=, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0007 leave</span>
</code></pre></div></div>

<h2 id="optnewarraymax">opt_newarray_max</h2>

<h3 id="summary-47">Summary</h3>

<p><code>opt_newarray_max</code> is an instruction that represents calling <code>max</code> on an
array literal. It is used to optimize quick comparisons of array elements.</p>

<h3 id="tracepoint-47">TracePoint</h3>

<p><code>opt_newarray_max</code> does not dispatch any events.</p>

<h3 id="usage-47">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">].</span><span class="nf">max</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,14)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 putobject_INT2FIX_1_                                             (   1)[Li]</span>
<span class="c1"># 0001 putobject                              2</span>
<span class="c1"># 0003 dup</span>
<span class="c1"># 0004 setlocal_WC_0                          x@0</span>
<span class="c1"># 0006 opt_newarray_max                       2</span>
<span class="c1"># 0008 leave</span>
</code></pre></div></div>

<h2 id="optnewarraymin">opt_newarray_min</h2>

<h3 id="summary-48">Summary</h3>

<p><code>opt_newarray_min</code> is an instruction that represents calling <code>min</code> on an
array literal. It is used to optimize quick comparisons of array elements.</p>

<h3 id="tracepoint-48">TracePoint</h3>

<p><code>opt_newarray_min</code> does not dispatch any events.</p>

<h3 id="usage-48">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">].</span><span class="nf">min</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,14)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 putobject_INT2FIX_1_                                             (   1)[Li]</span>
<span class="c1"># 0001 putobject                              2</span>
<span class="c1"># 0003 dup</span>
<span class="c1"># 0004 setlocal_WC_0                          x@0</span>
<span class="c1"># 0006 opt_newarray_min                       2</span>
<span class="c1"># 0008 leave</span>
</code></pre></div></div>

<h2 id="optnilp">opt_nil_p</h2>

<h3 id="summary-49">Summary</h3>

<p><code>opt_nil_p</code> is an optimization applied when the method <code>nil?</code> is called. It
returns true immediately when the receiver is <code>nil</code> and defers to the <code>nil?</code>
method in other cases</p>

<h3 id="tracepoint-49">TracePoint</h3>

<p><code>opt_nil_p</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-49">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">""</span><span class="p">.</span><span class="nf">nil?</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 opt_nil_p                              &lt;calldata!mid:nil?, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="optnot">opt_not</h2>

<h3 id="summary-50">Summary</h3>

<p><code>opt_not</code> negates the value on top of the stack.</p>

<h3 id="tracepoint-50">TracePoint</h3>

<p><code>opt_not</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-50">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!</span><span class="kp">true</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              true                      (   1)[Li]</span>
<span class="c1"># 0002 opt_not                                &lt;calldata!mid:!, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="optor">opt_or</h2>

<h3 id="summary-51">Summary</h3>

<p><code>opt_or</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>|</code> operator is used. In CRuby, there are fast paths
for if both operands are integers.</p>

<h3 id="tracepoint-51">TracePoint</h3>

<p><code>opt_or</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-51">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">|</span> <span class="mi">3</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_or                                 &lt;calldata!mid:|, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optplus">opt_plus</h2>

<h3 id="summary-52">Summary</h3>

<p><code>opt_plus</code> is a specialization of the <code>opt_send_without_block</code> instruction
that occurs when the <code>+</code> operator is used. In CRuby, there are fast paths
for if both operands are integers, floats, strings, or arrays.</p>

<h3 id="tracepoint-52">TracePoint</h3>

<p><code>opt_plus</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-52">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              2                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              3</span>
<span class="c1"># 0004 opt_plus                               &lt;calldata!mid:+, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optregexpmatch2">opt_regexpmatch2</h2>

<h3 id="summary-53">Summary</h3>

<p><code>opt_regexpmatch2</code> is a specialization of the <code>opt_send_without_block</code>
instruction that occurs when the <code>=~</code> operator is used.</p>

<h3 id="tracepoint-53">TracePoint</h3>

<p><code>opt_regexpmatch2</code> can dispatch both the <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-53">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/a/</span> <span class="o">=~</span> <span class="s2">"a"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,10)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              /a/                       (   1)[Li]</span>
<span class="c1"># 0002 putstring                              "a"</span>
<span class="c1"># 0004 opt_regexpmatch2                       &lt;calldata!mid:=~, argc:1, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0006 leave</span>
</code></pre></div></div>

<h2 id="optsendwithoutblock">opt_send_without_block</h2>

<h3 id="summary-54">Summary</h3>

<p><code>opt_send_without_block</code> is a specialization of the send instruction that
occurs when a method is being called without a block.</p>

<h3 id="tracepoint-54">TracePoint</h3>

<p><code>opt_send_without_block</code> does not dispatch any events.</p>

<h3 id="usage-54">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="s2">"Hello, world!"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,20)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putself                                                          (   1)[Li]</span>
<span class="c1"># 0001 putstring                              "Hello, world!"</span>
<span class="c1"># 0003 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="optsetinlinecache">opt_setinlinecache</h2>

<h3 id="summary-55">Summary</h3>

<p><code>opt_setinlinecache</code> is the final instruction after a series of
<code>getconstant</code> instructions that populates the inline cache associated with
an <code>opt_getinlinecache</code> instruction.</p>

<h3 id="tracepoint-55">TracePoint</h3>

<p><code>opt_setinlinecache</code> does not dispatch any events.</p>

<h3 id="usage-55">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Constant</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 opt_getinlinecache                     9, &lt;is:0&gt;                 (   1)[Li]</span>
<span class="c1"># 0003 putobject                              true</span>
<span class="c1"># 0005 getconstant                            :Constant</span>
<span class="c1"># 0007 opt_setinlinecache                     &lt;is:0&gt;</span>
<span class="c1"># 0009 leave</span>
</code></pre></div></div>

<h2 id="optsize">opt_size</h2>

<h3 id="summary-56">Summary</h3>

<p><code>opt_size</code> is a specialization of <code>opt_send_without_block</code>, when the
<code>size</code> method is called on a Ruby type with a known size. In CRuby there
are fast paths when the receiver is either a String, Hash or Array.</p>

<h3 id="tracepoint-56">TracePoint</h3>

<p><code>opt_size</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-56">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">""</span><span class="p">.</span><span class="nf">size</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 opt_size                               &lt;calldata!mid:size, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="optstrfreeze">opt_str_freeze</h2>

<h3 id="summary-57">Summary</h3>

<p><code>opt_str_freeze</code> pushes a frozen known string value with no interpolation
onto the stack.</p>

<h3 id="tracepoint-57">TracePoint</h3>

<p><code>opt_str_freeze</code> does not dispatch any events.</p>

<h3 id="usage-57">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"hello"</span><span class="p">.</span><span class="nf">freeze</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,14)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 opt_str_freeze                         "hello", &lt;calldata!mid:freeze, argc:0, ARGS_SIMPLE&gt;(   1)[Li]</span>
<span class="c1"># 0003 leave</span>
</code></pre></div></div>

<h2 id="optstruminus">opt_str_uminus</h2>

<h3 id="summary-58">Summary</h3>

<p><code>opt_str_uminus</code> pushes a frozen known string value with no interpolation
onto the stack.</p>

<h3 id="tracepoint-58">TracePoint</h3>

<p><code>opt_str_uminus</code> does not dispatch any events.</p>

<h3 id="usage-58">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-</span><span class="s2">"string"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 opt_str_uminus                         "string", &lt;calldata!mid:-@, argc:0, ARGS_SIMPLE&gt;(   1)[Li]</span>
<span class="c1"># 0003 leave</span>
</code></pre></div></div>

<h2 id="optsucc">opt_succ</h2>

<h3 id="summary-59">Summary</h3>

<p><code>opt_succ</code> is a specialization of the <code>opt_send_without_block</code> instruction
when the method being called is <code>succ</code>. Fast paths exist within CRuby when
the receiver is either a String or a Fixnum.</p>

<h3 id="tracepoint-59">TracePoint</h3>

<p><code>opt_succ</code> can dispatch <code>c_call</code> and <code>c_return</code> events.</p>

<h3 id="usage-59">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">""</span><span class="p">.</span><span class="nf">succ</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 opt_succ                               &lt;calldata!mid:succ, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0004 leave</span>
</code></pre></div></div>

<h2 id="pop">pop</h2>

<h3 id="summary-60">Summary</h3>

<p><code>pop</code> pops the top value off the stack.</p>

<h3 id="tracepoint-60">TracePoint</h3>

<p><code>pop</code> does not dispatch any events.</p>

<h3 id="usage-60">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">||=</span> <span class="mi">2</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] a@0</span>
<span class="c1"># 0000 getlocal_WC_0                          a@0                       (   1)[Li]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 branchif                               11</span>
<span class="c1"># 0005 pop</span>
<span class="c1"># 0006 putobject                              2</span>
<span class="c1"># 0008 dup</span>
<span class="c1"># 0009 setlocal_WC_0                          a@0</span>
<span class="c1"># 0011 leave</span>
</code></pre></div></div>

<h2 id="putnil">putnil</h2>

<h3 id="summary-61">Summary</h3>

<p><code>putnil</code> pushes a global nil object onto the stack.</p>

<h3 id="tracepoint-61">TracePoint</h3>

<p><code>putnil</code> can dispatch the line event.</p>

<h3 id="usage-61">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kp">nil</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,3)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putnil                                                           (   1)[Li]</span>
<span class="c1"># 0001 leave</span>
</code></pre></div></div>

<h2 id="putobject">putobject</h2>

<h3 id="summary-62">Summary</h3>

<p><code>putobject</code> pushes a known value onto the stack.</p>

<h3 id="tracepoint-62">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-62">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 leave</span>
</code></pre></div></div>

<h2 id="putobjectint2fix0">putobject_int2fix_0</h2>

<h3 id="summary-63">Summary</h3>

<p><code>putobject_INT2FIX_0_</code> pushes 0 on the stack.
It is a specialized instruction resulting from the operand
unification optimization. It is the equivalent to <code>putobject 0</code>.</p>

<h3 id="tracepoint-63">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-63">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject_INT2FIX_0_                                             (   1)[Li]</span>
<span class="c1"># 0001 leave</span>
</code></pre></div></div>

<h2 id="putobjectint2fix1">putobject_int2fix_1</h2>

<h3 id="summary-64">Summary</h3>

<p><code>putobject_INT2FIX_1_</code> pushes 1 on the stack.
It is a specialized instruction resulting from the operand
unification optimization. It is the equivalent to <code>putobject 1</code>.</p>

<h3 id="tracepoint-64">TracePoint</h3>

<p><code>putobject</code> can dispatch the line event.</p>

<h3 id="usage-64">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,1)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject_INT2FIX_1_                                             (   1)[Li]</span>
<span class="c1"># 0001 leave</span>
</code></pre></div></div>

<h2 id="putself">putself</h2>

<h3 id="summary-65">Summary</h3>

<p><code>putself</code> pushes the current value of self onto the stack.</p>

<h3 id="tracepoint-65">TracePoint</h3>

<p><code>putself</code> can dispatch the line event.</p>

<h3 id="usage-65">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="s2">"Hello, world!"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,20)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putself                                                          (   1)[Li]</span>
<span class="c1"># 0001 putstring                              "Hello, world!"</span>
<span class="c1"># 0003 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="putstring">putstring</h2>

<h3 id="summary-66">Summary</h3>

<p><code>putstring</code> pushes a string literal onto the stack.</p>

<h3 id="tracepoint-66">TracePoint</h3>

<p><code>putstring</code> can dispatch the line event.</p>

<h3 id="usage-66">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"foo"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,5)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              "foo"                     (   1)[Li]</span>
<span class="c1"># 0002 leave</span>
</code></pre></div></div>

<h2 id="send">send</h2>

<h3 id="summary-67">Summary</h3>

<p><code>send</code> invokes a method with a block.</p>

<h3 id="tracepoint-67">TracePoint</h3>

<p><code>send</code> does not dispatch any events.</p>

<h3 id="usage-67">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"hello"</span><span class="p">.</span><span class="nf">tap</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">p</span> <span class="n">i</span> <span class="p">}</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,23)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              "hello"                   (   1)[Li]</span>
<span class="c1"># 0002 send                                   &lt;calldata!mid:tap, argc:0&gt;, block in &lt;main&gt;</span>
<span class="c1"># 0005 leave</span>
<span class="c1">#</span>
<span class="c1"># == disasm: #&lt;ISeq:block in &lt;main&gt;@-e:1 (1,12)-(1,23)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 1 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] i@0&lt;Arg&gt;</span>
<span class="c1"># 0000 putself                                                          (   1)[LiBc]</span>
<span class="c1"># 0001 getlocal_WC_0                          i@0</span>
<span class="c1"># 0003 opt_send_without_block                 &lt;calldata!mid:p, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0005 leave                                  [Br]</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,23)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putstring                              "hello"                   (   1)[Li]</span>
<span class="c1"># 0002 send                                   &lt;calldata!mid:tap, argc:0&gt;, block in &lt;compiled&gt;</span>
<span class="c1"># 0005 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block in &lt;compiled&gt;@&lt;compiled&gt;:1 (1,12)-(1,23)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 1 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] i@0&lt;Arg&gt;</span>
<span class="c1"># 0000 putself                                                          (   1)[LiBc]</span>
<span class="c1"># 0001 getlocal_WC_0                          i@0</span>
<span class="c1"># 0003 opt_send_without_block                 &lt;calldata!mid:p, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0005 leave                                  [Br]</span>
</code></pre></div></div>

<h2 id="setglobal">setglobal</h2>

<h3 id="summary-68">Summary</h3>

<p><code>setglobal</code> sets the value of a global variable.</p>

<h3 id="tracepoint-68">TracePoint</h3>

<p><code>setglobal</code> does not dispatch any events.</p>

<h3 id="usage-68">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$global</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,11)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 setglobal                              :$global</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="setlocal">setlocal</h2>

<h3 id="summary-69">Summary</h3>

<p><code>setlocal</code> sets the value of a local variable on a frame determined by the
level and index arguments. The level is the number of frames back to
look and the index is the index in the local table. It pops the value it is
setting off the stack.</p>

<h3 id="tracepoint-69">TracePoint</h3>

<p><code>setlocal</code> does not dispatch any events.</p>

<h3 id="usage-69">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">tap</span> <span class="p">{</span> <span class="n">tap</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">}</span> <span class="p">}</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(2,26)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] value@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          value@0</span>
<span class="c1"># 0004 putself                                                          (   2)[Li]</span>
<span class="c1"># 0005 send                                   &lt;calldata!mid:tap, argc:0, FCALL&gt;, block in &lt;compiled&gt;</span>
<span class="c1"># 0008 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block in &lt;compiled&gt;@&lt;compiled&gt;:2 (2,4)-(2,26)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putself                                                          (   2)[LiBc]</span>
<span class="c1"># 0001 send                                   &lt;calldata!mid:tap, argc:0, FCALL&gt;, block (2 levels) in &lt;compiled&gt;</span>
<span class="c1"># 0004 leave                                  [Br]</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block (2 levels) in &lt;compiled&gt;@&lt;compiled&gt;:2 (2,10)-(2,24)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              10                        (   2)[LiBc]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 setlocal                               value@0, 2</span>
<span class="c1"># 0006 leave                                  [Br]</span>
</code></pre></div></div>

<h2 id="setlocalwc0">setlocal_wc_0</h2>

<h3 id="summary-70">Summary</h3>

<p><code>setlocal_WC_0</code> is a specialized version of the <code>setlocal</code> instruction. It
sets the value of a local variable on the current frame to the value at the
top of the stack as determined by the index given as its only argument.</p>

<h3 id="tracepoint-70">TracePoint</h3>

<p><code>setlocal_WC_0</code> does not dispatch any events.</p>

<h3 id="usage-70">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,9)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] value@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 setlocal_WC_0                          value@0</span>
<span class="c1"># 0005 leave</span>
</code></pre></div></div>

<h2 id="setlocalwc1">setlocal_wc_1</h2>

<h3 id="summary-71">Summary</h3>

<p><code>setlocal_WC_1</code> is a specialized version of the <code>setlocal</code> instruction. It
sets the value of a local variable on the parent frame to the value at the
top of the stack as determined by the index given as its only argument.</p>

<h3 id="tracepoint-71">TracePoint</h3>

<p><code>setlocal_WC_1</code> does not dispatch any events.</p>

<h3 id="usage-71">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="o">=</span> <span class="mi">5</span>
<span class="nb">self</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">}</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(2,24)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] value@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 setlocal_WC_0                          value@0</span>
<span class="c1"># 0004 putself                                                          (   2)[Li]</span>
<span class="c1"># 0005 send                                   &lt;calldata!mid:then, argc:0, FCALL&gt;, block in &lt;compiled&gt;</span>
<span class="c1"># 0008 leave</span>
<span class="c1"># </span>
<span class="c1"># == disasm: #&lt;ISeq:block in &lt;compiled&gt;@&lt;compiled&gt;:2 (2,10)-(2,24)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              10                        (   2)[LiBc]</span>
<span class="c1"># 0002 dup</span>
<span class="c1"># 0003 setlocal_WC_1                          value@0</span>
<span class="c1"># 0005 leave                                  [Br]</span>
</code></pre></div></div>

<h2 id="setn">setn</h2>

<h3 id="summary-72">Summary</h3>

<p><code>setn</code> is an instruction for set Nth stack entry to stack top</p>

<h3 id="tracepoint-72">TracePoint</h3>

<p># <code>setn</code> does not dispatch any events.</p>

<h3 id="usage-72">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{}[</span><span class="ss">:key</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'val'</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,16)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putnil                                                           (   1)[Li]</span>
<span class="c1"># 0001 newhash                                0</span>
<span class="c1"># 0003 putobject                              :key</span>
<span class="c1"># 0005 putstring                              "val"</span>
<span class="c1"># 0007 setn                                   3</span>
<span class="c1"># 0009 opt_aset                               &lt;calldata!mid:[]=, argc:2, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0011 pop</span>
<span class="c1"># 0012 leave</span>
</code></pre></div></div>

<h2 id="splatarray">splatarray</h2>

<h3 id="summary-73">Summary</h3>

<p><code>splatarray</code> calls to_a on an array to splat.</p>

<p>It coerces the array object at the top of the stack into Array by calling
<code>to_a</code>. It pushes a duplicate of the array if there is a flag, and the original
array, if there isn’t one.</p>

<h3 id="tracepoint-73">TracePoint</h3>

<p><code>splayarray</code> does not dispatch any events.</p>

<h3 id="usage-73">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,8)&gt; (catch: FALSE)</span>
<span class="c1"># local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># [ 1] x@0</span>
<span class="c1"># 0000 putobject                              5                         (   1)[Li]</span>
<span class="c1"># 0002 splatarray                             true</span>
<span class="c1"># 0004 dup</span>
<span class="c1"># 0005 setlocal_WC_0                          x@0</span>
<span class="c1"># 0007 leave</span>
</code></pre></div></div>

<h2 id="swap">swap</h2>

<h3 id="summary-74">Summary</h3>

<p><code>swap</code> swaps the top two elements in the stack.</p>

<h3 id="tracepoint-74">TracePoint</h3>

<p><code>swap</code> does not dispatch any events.</p>

<h3 id="usage-74">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">!!</span><span class="k">defined?</span><span class="p">([[]])</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,16)&gt; (catch: TRUE)</span>
<span class="c1"># == catch table</span>
<span class="c1"># | catch type: rescue st: 0001 ed: 0003 sp: 0000 cont: 0005</span>
<span class="c1"># | == disasm: #&lt;ISeq:defined guard in &lt;compiled&gt;@&lt;compiled&gt;:0 (0,0)-(-1,-1)&gt; (catch: FALSE)</span>
<span class="c1"># | local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])</span>
<span class="c1"># | [ 1] $!@0</span>
<span class="c1"># | 0000 putnil</span>
<span class="c1"># | 0001 leave</span>
<span class="c1"># |------------------------------------------------------------------------</span>
<span class="c1"># 0000 putnil                                                           (   1)[Li]</span>
<span class="c1"># 0001 putobject                              "expression"</span>
<span class="c1"># 0003 swap</span>
<span class="c1"># 0004 pop</span>
<span class="c1"># 0005 opt_not                                &lt;calldata!mid:!, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0007 opt_not                                &lt;calldata!mid:!, argc:0, ARGS_SIMPLE&gt;[CcCr]</span>
<span class="c1"># 0009 leave</span>
</code></pre></div></div>

<h2 id="topn">topn</h2>

<h3 id="summary-75">Summary</h3>

<p><code>topn</code> has one argument: <code>n</code>. It gets the nth element from the top of the
stack and pushes it on the stack.</p>

<h3 id="tracepoint-75">TracePoint</h3>

<p><code>topn</code> does not dispatch any events.</p>

<h3 id="usage-75">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">3</span>
<span class="k">when</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span>
  <span class="nb">puts</span> <span class="s2">"foo"</span>
<span class="k">end</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,36)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              3                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              1..5</span>
<span class="c1"># 0004 topn                                   1</span>
<span class="c1"># 0006 opt_send_without_block                 &lt;calldata!mid:===, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0008 branchif                               13</span>
<span class="c1"># 0010 pop</span>
<span class="c1"># 0011 putnil</span>
<span class="c1"># 0012 leave</span>
<span class="c1"># 0013 pop</span>
<span class="c1"># 0014 putself</span>
<span class="c1"># 0015 putstring                              "foo"</span>
<span class="c1"># 0017 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0019 leave</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(4,3)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              3                         (   1)[Li]</span>
<span class="c1"># 0002 putobject                              1..5                      (   2)</span>
<span class="c1"># 0004 topn                                   1</span>
<span class="c1"># 0006 opt_send_without_block                 &lt;calldata!mid:===, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0008 branchif                               13</span>
<span class="c1"># 0010 pop                                                              (   1)</span>
<span class="c1"># 0011 putnil</span>
<span class="c1"># 0012 leave                                                            (   3)</span>
<span class="c1"># 0013 pop                                                              (   2)</span>
<span class="c1"># 0014 putself                                                          (   3)[Li]</span>
<span class="c1"># 0015 putstring                              "foo"</span>
<span class="c1"># 0017 opt_send_without_block                 &lt;calldata!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0019 leave</span>
</code></pre></div></div>

<h2 id="toregexp">toregexp</h2>

<h3 id="summary-76">Summary</h3>

<p><code>toregexp</code> is generated when string interpolation is used inside a regex
literal <code>//</code>. It pops a defined number of values from the stack, combines
them into a single string and coerces that string into a <code>Regexp</code> object,
which it pushes back onto the stack</p>

<h3 id="tracepoint-76">TracePoint</h3>

<p><code>toregexp</code> cannot dispatch any TracePoint events.</p>

<h3 id="usage-76">Usage</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"/</span><span class="si">#{</span><span class="kp">true</span><span class="si">}</span><span class="s2">/"</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,9)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              ""                        (   1)[Li]</span>
<span class="c1"># 0002 putobject                              true</span>
<span class="c1"># 0004 dup</span>
<span class="c1"># 0005 objtostring                            &lt;calldata!mid:to_s, argc:0, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0007 anytostring</span>
<span class="c1"># 0008 toregexp                               0, 2</span>
<span class="c1"># 0011 leave</span>

<span class="c1"># == disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,11)&gt; (catch: FALSE)</span>
<span class="c1"># 0000 putobject                              "/"                       (   1)[Li]</span>
<span class="c1"># 0002 putobject                              true</span>
<span class="c1"># 0004 dup</span>
<span class="c1"># 0005 objtostring                            &lt;calldata!mid:to_s, argc:0, FCALL|ARGS_SIMPLE&gt;</span>
<span class="c1"># 0007 anytostring</span>
<span class="c1"># 0008 putobject                              "/"</span>
<span class="c1"># 0010 concatstrings                          3</span>
<span class="c1"># 0012 leave</span>
</code></pre></div></div>


</article>

    </main>
  </body>
</html>
